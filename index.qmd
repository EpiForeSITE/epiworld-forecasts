---
title: "Weekly COVID-19 Forecast for Utah"
date: last-modified
execute:
  echo: false
---

## Introduction

Using case data published by the Utah DHHS and the [epiworldR](https://github.com/UofUEpiBio/epiworldR) package, we calibrate and run an SIR connected model to generate a COVID-19 forecast for Utah, which is published weekly.

## COVID-19 Cases in Utah (last 90 days)
Every week, Utah DHHS publishes COVID-19 surveillance data on their [Coronavirus Dashboard](https://coronavirus.utah.gov/case-counts/) which includes reported case counts for each day starting March 18, 2020.
Our forecast is calibrated on case counts from the last 90 days.

```{r}
#| label: get-data
#| cache: true
# Download the Trends data from Utah DHHS
source("get-forecast-data.R")
data_url <- "https://coronavirus-dashboard.utah.gov/Utah_COVID19_data.zip"
target_file_regex <- "Trends_Epidemic+"
forecast_data <- get_forecast_data(data_url, target_file_regex)
forecast_data$Date <- as.Date(forecast_data$Date)

# Get data from last 90 days
last_date <- max(forecast_data$Date)
forecast_data <- forecast_data[forecast_data$Date > (last_date - 90), ]
```

```{r}
#| label: plot-data
#| fig-width: 7
#| fig-height: 3
#| fig-align: center
library(ggplot2)
ggplot(forecast_data, aes(x = Date, y = Daily.Cases)) +
  geom_line() +
  labs(x = "Date", y = "Daily Cases") +
  theme_classic()

# Identify the start date of each season (spring, summer, fall, winter) in data
get_date_season <- function(date) {
  date_month <- as.integer(format(as.Date(date, format = "%d/%m/%Y"), "%m"))

  if (date_month >= 3 && date_month <= 5) {
    return("spring")
  } else if (date_month >= 6 && date_month <= 8) {
    return("summer")
  } else if (date_month >= 9 && date_month <= 11) {
    return("fall")
  } else {
    return("winter")
  }
}
forecast_seasons <- mapply(get_date_season, forecast_data$Date)

spring_start <- match("spring", forecast_seasons, nomatch = -1)
summer_start <- match("summer", forecast_seasons, nomatch = -1)
fall_start <- match("fall", forecast_seasons, nomatch = -1)
winter_start <- match("winter", forecast_seasons, nomatch = -1)
```

## Calibrating the Forecasting Model
We use epiworldR's implementation of Likelihood-Free Markhov Chain Monte Carlo (LFMCMC) to calibrate the SIR connected model (using ModelSIRCONN from epiworldR) by estimating the following model parameters:
- Recovery rate
- Transmission rates for each season (spring, summer, fall, winter)
- Contact rates for weekdays and weekends

The LFMCMC simulation runs for 1,000 iterations.
In each iteration, it does the following:
- Proposes a new set of parameter values
- Runs the model with 10,000 agents and the proposed parameters
- Compares the output to the UDHHS data and records the result

```{r}
#| label: prep-model
library(epiworldR)

# Extract cases from observed data
forecast_data_cases <- forecast_data$Daily.Cases

# Set model parameters
model_seed <- 112
model_ndays <- 90
model_n <- 10000  # model population size
n_samples <- 1000 # number of LFMCMC iterations
lfmcmc_epsilon <- 0.25

init_prevalence <- forecast_data_cases[1] / model_n
init_contact_rate <- 10
init_transmission_rate <- 0.05

init_lfmcmc_params <- c(
  1 / 7,  # recovery_rate
  0.05,   # t_rate_spring
  0.04,   # t_rate_summer
  0.06,   # t_rate_fall
  0.07,   # t_rate_winter
  10,     # contact_rate_weekday
  2       # contact_rate_weekend
)

# Create the base SIRCONN model
ef_model <- ModelSIRCONN(
  name              = "COVID-19",
  n                 = model_n,
  prevalence        = init_prevalence,
  contact_rate      = init_contact_rate,
  transmission_rate = init_transmission_rate,
  recovery_rate     = init_lfmcmc_params[1]
)
```

```{r}
#| label: setup-lfmcmc
# Define the LFMCMC simulation function
lfmcmc_simulation_fun <- function(params) {
  # Extract parameters
  recovery_rate        <- params[1]
  t_rate_spring        <- params[2]
  t_rate_summer        <- params[3]
  t_rate_fall          <- params[4]
  t_rate_winter        <- params[5]
  contact_rate_weekday <- params[6]
  contact_rate_weekend <- params[7]

  # Set recovery rate
  set_param(ef_model, "Recovery rate", recovery_rate)

  # Global event to change contact and transmission rates
  change_c_and_t_rates <- function(model) {
    # Get the current model day (step)
    current_model_day <- today(model)

    ## Update contact rate based on weekday/weekend
    if (any(c(6, 0) %in% (current_model_day %% 7L))) {
      set_param(model, "Contact rate", contact_rate_weekend)
    } else {
      set_param(model, "Contact rate", contact_rate_weekday)
    }

    ## Update transmission rate each season
    if (current_model_day == spring_start) {
      set_param(model, "Transmission rate", t_rate_spring)
    } else if (current_model_day == summer_start) {
      set_param(model, "Transmission rate", t_rate_summer)
    } else if (current_model_day == fall_start) {
      set_param(model, "Transmission rate", t_rate_fall)
    } else if (current_model_day == winter_start) {
      set_param(model, "Transmission rate", t_rate_winter)
    }

    invisible(model)
  }

  # Add global event to the model
  change_c_and_t_event_name <- "Change Contact and Transmission Rates"
  globalevent_fun(change_c_and_t_rates, name = change_c_and_t_event_name) |>
    add_globalevent(model = ef_model)

  # Run the model
  verbose_off(ef_model)
  run(ef_model, ndays = model_ndays)

  # Remove global event (new event set each simulation run)
  rm_globalevent(ef_model, change_c_and_t_event_name)

  # Get infected cases
  hist_matrix <- get_hist_transition_matrix(ef_model)

  # - Model returns 91 values so we drop the last value
  infected_cases <- head(
    hist_matrix[grep("Infected", hist_matrix$state_to), "counts"],
    -1
  )

  return(as.double(infected_cases))
}

# Define the LFMCMC summary function
lfmcmc_summary_fun <- function(case_counts) {
  # Extract summary statistics from the data
  time_to_peak <- which.max(case_counts)
  size_of_peak <- case_counts[time_to_peak]
  mean_cases <- mean(case_counts)
  sd_cases <- sd(case_counts)

  c(
    time_to_peak,
    size_of_peak,
    mean_cases,
    sd_cases
  )
}

# Define the LFMCMC summary function
lfmcmc_proposal_fun <- function(params_prev) {
  # Propose new model parameters
  params_1_to_5 <- plogis(
    qlogis(params_prev[1:5]) +
      rnorm(length(params_prev[1:5]), mean = 0, sd = 0.1)
  )

  params_6_to_7 <- params_prev[6:7] +
    rnorm(2, mean = 0, sd = 0.1)


  # Reflect contact rates
  if (params_6_to_7[1] < 0) {
    params_6_to_7[1] <- params_prev[6] -
      (params_6_to_7[1] - params_prev[6])
  }
  if (params_6_to_7[2] < 0) {
    params_6_to_7[2] <- params_prev[7] -
      (params_6_to_7[2] - params_prev[7])
  }

  # Return proposed parameters
  c(params_1_to_5, params_6_to_7)
}

# Define the LFMCMC kernel function
# - Weighs simulation results against observed data
lfmcmc_kernel_fun <- function(stats_now, stats_obs, epsilon) {
  diff <- ((stats_now - stats_obs)^2)^epsilon
  dnorm(sqrt(sum(diff)))
}

# Create the LFMCMC model
lfmcmc_model <- LFMCMC(ef_model) |>
  set_simulation_fun(lfmcmc_simulation_fun) |>
  set_summary_fun(lfmcmc_summary_fun) |>
  set_proposal_fun(lfmcmc_proposal_fun) |>
  set_kernel_fun(lfmcmc_kernel_fun) |>
  set_observed_data(forecast_data_cases)
```

```{r}
#| label: run-lfmcmc
run_lfmcmc(
  lfmcmc = lfmcmc_model,
  params_init_ = init_lfmcmc_params,
  n_samples_ = n_samples,
  epsilon_ = lfmcmc_epsilon,
  seed = model_seed
)
```

When the simulation is finished, we use a burn-in period of n = 500 (50% of simulation iterations).
The epiworldR results printout (below) shows the mean parameter/statistic value, the 95% credible interval (in [ ]), and the initial/observed value (in ()).
```{r}
#| label: print-results
# Print the results with 50% burnin
par_names <- c(
  "Recovery rate",
  "Transmission rate (spring)",
  "Transmission rate (summer)",
  "Transmission rate (fall)",
  "Transmission rate (winter)",
  "Contact rate (weekday)",
  "Contact rate (weekend)"
)
set_par_names(lfmcmc_model, par_names)

stats_names <- c(
  "Time to peak",
  "Size of peak",
  "Mean (cases)",
  "Standard deviation (cases)"
)
set_stats_names(lfmcmc_model, stats_names)

print(lfmcmc_model, burnin = n_samples / 2)
```
Here is the posterior distribution of the LFMCMC samples:
```{r}
#| label: get-posterior-dist
res <- get_accepted_params(lfmcmc_model)
res <- lapply(seq_along(par_names), \(i) {
  data.frame(
    step  = seq_along(nrow(res)),
    param = par_names[i],
    value = res[, i]
  )
}) |> do.call(what = "rbind")

res_r_rate <- res[res$param == par_names[1], ]
res_t_rate <- res[res$param == par_names[2:5], ]
res_c_rate <- res[res$param == par_names[6:7], ]
res_r_c_rate <- rbind(res_r_rate, res_c_rate)

ggplot(res_r_c_rate, aes(x = value, fill = param, ..scaled..)) +
  geom_density(alpha = .3) +
  facet_wrap(~param, scales = "free") +
  theme_light()

ggplot(res_t_rate, aes(x = value, fill = param, ..scaled..)) +
  geom_density(alpha = .3) +
  theme_light()
```

## Epiworld Forecast

We can now run the forecast.
We first find the second quantile from the accepted parameters and then run the SIR connected model with those parameters.
```{r}
# Run with estimated parameters
accepted_params <- get_accepted_params(lfmcmc_model)
params_median <- accepted_params[-c(1:(n_samples / 2)), ] |>
  apply(2, quantile, probs = c(.5))

forecasted_cases <- lfmcmc_simulation_fun(params_median)

# Print Model Summary and Plot Incidence
summary(ef_model)
plot_incidence(ef_model)
```

## Acknowledgements
This forecast was developed jointly by Andrew Pulsipher and George Vega Yon as part of the EpiForeSITE project.
