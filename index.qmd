---
title: "Weekly COVID-19 Forecast for Utah"
date: last-modified
execute:
  echo: false
---

## Introduction

Using case data published by the Utah DHHS and the [epiworldR](https://github.com/UofUEpiBio/epiworldR) package, we calibrate and run an SIR connected model to generate a COVID-19 forecast for Utah, which is published weekly.

## COVID-19 Cases in Utah (last 90 days)
Every week, Utah DHHS publishes COVID-19 surveillance data on their [Coronavirus Dashboard](https://coronavirus.utah.gov/case-counts/) which includes reported case counts for each day starting March 18, 2020.
Our forecast is calibrated on case counts from the last 90 days.

```{r}
#| label: get-data
#| cache: true
# Load in needed files
source("covid-forecast.R")

# TODO: make all of this into a single running script
## ----------------------------------
## Setup Forecast
## ----------------------------------
# Define forecast parameters
n_days <- 90 # Calibrate model last 90 days of data


## ----------------------------------
## Get Data
## ----------------------------------

# Get COVID-19 data
covid_data <- get_covid_data(n_days)
# Compute start date for each season
seasons <- get_season_starts(covid_data$Date)
# Get observed case counts
covid_cases <- covid_data$Daily.Cases

plot_covid_data(covid_data)

## ----------------------------------
## Create SIR CONN Model
## ----------------------------------

# Define SIRCONN model parameters
model_seed          <- 112      # Random seed
model_ndays         <- n_days   # How many days to run the model
model_n             <- 10000    # model population size

# Define initial disease parameters
init_prevalence <- covid_cases[1] / model_n
init_contact_rate <- 10
init_transmission_rate <- 0.05
init_recovery_rate <- 1 / 7

# Create the SIRCONN model
covid_sirconn_model <- ModelSIRCONN(
  name              = "COVID-19",
  n                 = model_n,
  prevalence        = init_prevalence,
  contact_rate      = init_contact_rate,
  transmission_rate = init_transmission_rate,
  recovery_rate     = init_recovery_rate
)
```

## Calibrating the Forecasting Model
We use epiworldR's implementation of Likelihood-Free Markhov Chain Monte Carlo (LFMCMC) to calibrate the SIR connected model (using ModelSIRCONN from epiworldR) by estimating the following model parameters:

* Recovery rate
* Transmission rates for each season (spring, summer, fall, winter)
* Contact rates for weekdays and weekends

The LFMCMC simulation runs for 3,000 iterations.
In each iteration, it does the following:

* Proposes a new set of parameter values
* Runs the model with 10,000 agents and the proposed parameters
* Compares the output to the UDHHS data and records the result

We note that while the population of Utah over 3 million, we only need to run our model with 10,000 agents.
This is because we don't expect more than 10,000 COVID-19 cases and the model automatically scales the contact rate to account for the difference between the model population and Utah's population.

```{r}
#| label: setup-lfmcmc

## ----------------------------------
## Setup LFMCMC Calibration
## ----------------------------------

# Define LFMCMC parameters
lfmcmc_n_samples <- 6000   # number of LFMCMC iterations
lfmcmc_burnin <- 2000    # burn-in period
lfmcmc_epsilon <- 0.25

init_lfmcmc_params <- c(
  1 / 7,  # r_rate
  0.05,   # t_rate_spring
  0.04,   # t_rate_summer
  0.06,   # t_rate_fall
  0.07,   # t_rate_winter
  10,     # c_rate_weekday
  2       # c_rate_weekend
)
param_names <- c(
  "Recovery rate",
  "Transmission rate (spring)",
  "Transmission rate (summer)",
  "Transmission rate (fall)",
  "Transmission rate (winter)",
  "Contact rate (weekday)",
  "Contact rate (weekend)"
)

stats_names <- c(
  "Time to peak",
  "Size of peak",
  "Mean (cases)",
  "Standard deviation (cases)"
)

# Define the LFMCMC simulation function
lfmcmc_simulation_fun <- function(params) {
  # Extract parameters
  r_rate          <- params[1]
  t_rate_spring   <- params[2]
  t_rate_summer   <- params[3]
  t_rate_fall     <- params[4]
  t_rate_winter   <- params[5]
  c_rate_weekday  <- params[6]
  c_rate_weekend  <- params[7]

  # Set recovery rate
  set_param(covid_sirconn_model, "Recovery rate", r_rate)

  # Global event to change contact and transmission rates
  change_c_and_t_rates <- function(model) {
    # Get the current model day (step)
    current_model_day <- today(model)

    ## Update contact rate based on weekday/weekend
    if (any(c(6, 0) %in% (current_model_day %% 7L))) {
      set_param(model, "Contact rate", c_rate_weekend)
    } else {
      set_param(model, "Contact rate", c_rate_weekday)
    }

    ## Update transmission rate each season
    if (current_model_day == seasons[["spring"]]) {
      set_param(model, "Transmission rate", t_rate_spring)
    } else if (current_model_day == seasons[["summer"]]) {
      set_param(model, "Transmission rate", t_rate_summer)
    } else if (current_model_day == seasons[["fall"]]) {
      set_param(model, "Transmission rate", t_rate_fall)
    } else if (current_model_day == seasons[["winter"]]) {
      set_param(model, "Transmission rate", t_rate_winter)
    }

    invisible(model)
  }

  # Add global event to the model
  change_c_and_t_event_name <- "Change Contact and Transmission Rates"
  globalevent_fun(change_c_and_t_rates, name = change_c_and_t_event_name) |>
    add_globalevent(model = covid_sirconn_model)

  # Run the model
  verbose_off(covid_sirconn_model)
  run(covid_sirconn_model, ndays = model_ndays)

  # Remove global event (new event set each simulation run)
  rm_globalevent(covid_sirconn_model, change_c_and_t_event_name)

  # Get infected cases
  hist_matrix <- get_hist_transition_matrix(covid_sirconn_model)
  # - Drop the last day of data because the model returns data for (model_ndays + 1) days
  infected_cases <- head(
    hist_matrix[
      hist_matrix$state_to == "Infected" &
        hist_matrix$state_from == "Susceptible",
      c("counts")],
    -1
  )

  return(as.double(infected_cases))
}

# Create the LFMCMC model
calibration_lfmcmc <- LFMCMC(covid_sirconn_model) |>
  set_simulation_fun(lfmcmc_simulation_fun) |>
  set_summary_fun(lfmcmc_summary_fun) |>
  set_proposal_fun(lfmcmc_proposal_fun) |>
  set_kernel_fun(lfmcmc_kernel_fun) |>
  set_observed_data(covid_cases)
```

```{r}
#| label: run-lfmcmc
run_lfmcmc(
  lfmcmc = calibration_lfmcmc,
  params_init_ = init_lfmcmc_params,
  n_samples_ = lfmcmc_n_samples,
  epsilon_ = lfmcmc_epsilon,
  seed = model_seed
)
set_params_names(calibration_lfmcmc, param_names)
set_stats_names(calibration_lfmcmc, stats_names)
```

When the simulation is finished, we use a burn-in period of n = 2000 (66% of simulation iterations).
The epiworldR results printout (below) shows the mean parameter/statistic value, the 95% credible interval (in [ ]), and the initial/observed value (in ()).
```{r}
#| label: print-results
print(calibration_lfmcmc, burnin = lfmcmc_burnin)
```

Here is the posterior distribution of the LFMCMC samples with vertical lines representing the initial parameter values.

```{r}
#| label: plot-posterior-dist
plot_lfmcmc_post_dist(calibration_lfmcmc, param_names, init_lfmcmc_params, seasons)
```

## Epiworld Forecast

We can now run the forecast.
Our model prevalence is set according to the reported case counts of the most recent day of the UDHHS data.
We then take a sample of n = 200 from the LFMCMC accepted parameters (after the burn-in period) and run the SIR connected model with the new prevalence for each set of parameters.
Each simulation is for two weeks, giving us a 14-day forecast of COVID-19 in Utah.
The forecast mean is shown below along with the 50% and 95% confidence intervals.

```{r}
#| label: run-forecast

# Create a new SIR CONN model
# - Compute prevalance based on most recent day
forecast_prevalence <- covid_cases[90] / model_n
# - Init the model
covid_sirconn_model <- ModelSIRCONN(
  name              = "COVID-19",
  n                 = model_n,
  prevalence        = forecast_prevalence,
  contact_rate      = init_contact_rate,
  transmission_rate = init_transmission_rate,
  recovery_rate     = init_recovery_rate
)

# Run the simulation for each set of params in the sample
# - Select sample of accepted params from LFMCMC
forecast_sample_n <- 200 # Sample size
params_sample <- get_params_sample(calibration_lfmcmc,
  lfmcmc_n_samples,
  lfmcmc_burnin,
  forecast_sample_n)
# - Set forecast length
model_ndays <- 14
# - Run simulation function for each set of params from the sample
forecast_dist <- apply(params_sample, 1, lfmcmc_simulation_fun)

plot_forecast(forecast_dist, covid_data)
```

## Acknowledgements
This forecast was developed jointly by Andrew Pulsipher and George Vega Yon as part of the EpiForeSITE project.
