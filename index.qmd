---
title: "Weekly COVID-19 Forecast for Utah"
date: last-modified
execute:
  echo: false
---

## Introduction

This COVID-19 forecast is published weekly.
Using case data published at the Utah DHHS [Coronavirus Dashboard](https://coronavirus.utah.gov/case-counts/), we calibrate an SIR connected model and simulate it with [epiworldR](https://github.com/UofUEpiBio/epiworldR) to generate the forecast.

The forecast was last updated on {{< meta date >}}.

## Overview of Observed Data
Utah DHHS publishes weekly surveillance data on their [Coronavirus Dashboard](https://coronavirus.utah.gov/case-counts/).
Below are the daily COVID-19 case counts from March 18, 2020 to {{< meta date >}}.

```{r}
# Download the Trends data from Utah DHHS
source("get-forecast-data.R")
data_url <- "https://coronavirus-dashboard.utah.gov/Utah_COVID19_data.zip"
target_file_regex <- "Trends_Epidemic+"
forecast_data <- get_forecast_data(data_url, target_file_regex)
forecast_data$Date <- as.Date(forecast_data$Date)
# Check for errors
if (length(forecast_data) > 1) {
  # Plot the observed data
  plot(
    x = as.Date(forecast_data$Date),
    y = forecast_data$Daily.Cases,
    xlab = "Date",
    ylab = "Daily Cases",
    main = "Daily COVID-19 Cases in Utah"
  )
}
```

Retrieving only for a few months

```{r}
library(ggplot2)

# Getting the last 3 months of data
last_date <- max(forecast_data$Date)
forecast_data <- forecast_data[forecast_data$Date > (last_date - 90), ]
ggplot(forecast_data, aes(x = Date, y = Daily.Cases)) +
  geom_line(aes(group = 1)) +
  labs(x = "Date", y = "Daily Cases", title = "Daily COVID-19 Cases in Utah")
```

Now, building a model that changes the transmission rate during the weekdays

```{r}
library(epiworldR)

get_date_season <- function(date) {
  date_month <- as.integer(format(as.Date(date, format = "%d/%m/%Y"), "%m"))

  if (date_month >= 3 && date_month <= 5) {
    return("spring")
  } else if (date_month >= 6 && date_month <= 8) {
    return("summer")
  } else if (date_month >= 9 && date_month <= 11) {
    return("fall")
  } else {
    return("winter")
  }
}

lfmcmc_simulation_fun <- function(params) {
  # Extract parameters
  recovery_rate <- params[1]
  t_rate_spring <- params[2]
  t_rate_summer <- params[3]
  t_rate_fall <- params[4]
  t_rate_winter <- params[5]
  contact_rate_weekday <- params[6]
  contact_rate_weekend <- params[7]
  # contact_rate_holiday <- params[8]

  # Create model using new recovery_rate
  ef_model <- ModelSIRCONN(
    name              = "COVID-19",
    n                 = 500000,
    prevalence        = 0.00001,
    contact_rate      = 10,
    transmission_rate = 0.05,
    recovery_rate     = recovery_rate
  )

  # Add a global event that changes the contact rate parameter
  contact_rate_day <- 0L
  change_contact_rate <- function(model) {
    # Check whether today is a weekday or weekend
    if (any(c(6, 0) %in% (contact_rate_day %% 7L))) {
      set_param(model, "Contact rate", contact_rate_weekend)
    } else {
      set_param(model, "Contact rate", contact_rate_weekday)
    }

    # TODO: Add cases to update contact rate for specific holidays (extract from the 90 days of data)

    # You don't want to do this... but
    # Replace this with the today() method once it is implemented.
    contact_rate_day <<- contact_rate_day + 1L

    invisible(model)
  }

  globalevent_fun(change_contact_rate, name = "Change Contact Rate") |>
    add_globalevent(model = ef_model)

  # Add a global event that changes the transmission rate parameter
  transmission_rate_day <- 0L
  change_transmission_rate <- function(model) {

    current_season <- get_date_season(forecast_data$Date[transmission_rate_day + 1])

    if (current_season == "spring") {
      set_param(model, "Transmission rate", t_rate_spring)
    } else if (current_season == "summer") {
      set_param(model, "Transmission rate", t_rate_summer)
    } else if (current_season == "fall") {
      set_param(model, "Transmission rate", t_rate_fall)
    } else {
      set_param(model, "Transmission rate", t_rate_winter)
    }

    # You don't want to do this... but
    # Replace this with the today() method once it is implemented.
    transmission_rate_day <<- transmission_rate_day + 1L

    invisible(model)
  }

  globalevent_fun(change_transmission_rate, name = "Change Transmission Rate") |>
    add_globalevent(model = ef_model)

  # Run the model
  run(ef_model, ndays = 90, seed = 112)

  # Printing Model Summary (TODO: delete this)
  summary(ef_model)
  plot_incidence(ef_model)

  # TODO: return infected cases
  res <- unname(as.integer(get_today_total(ef_model)))
  return(res)
}

lfmcmc_summary_fun <- function(dat) {
  # TODO: Extract summary statistics from the data
  # - time_to_peak (largest)
  # - size_of_peak (% of pop)
  # - sd_cases
  # - mean_cases
}

init_lfmcmc_params <- c(
  1 / 7,  # recovery_rate
  0.05,   # t_rate_spring
  0.04,   # t_rate_summer
  0.06,   # t_rate_fall
  0.05,   # t_rate_winter
  10,     # contact_rate_weekday
  2       # contact_rate_weekend
)

lfmcmc_simulation_fun(init_lfmcmc_params)
```

## Epiworld Forecast
We calibrate a SIR Connected model using the above data and run the model in epiworldR.
Here are the results of a single model run:
```{r}
model_sir <- ModelSIRCONN(
  name              = "COVID-19",
  n                 = 50000,
  prevalence        = 0.0001,
  contact_rate      = 2,
  transmission_rate = 0.5,
  recovery_rate     = 1 / 3
)

# Printing Model Summary
run(model_sir, ndays = 90, seed = 112)
```

## Methodology
Here we describe the process used for calibrating the model and generating the forecast.

## Acknowledgements
Here we acknowledge the contributions to the forecast.
